<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
  <version>5.0</version>
  <date>2021-10-26T04:41:46Z</date>
  <groups>
    <group>
      <name>Templates</name>
    </group>
  </groups>
  <templates>
    <template>
      <template>OS Windows Server Baseline</template>
      <name>OS Windows Server Baseline</name>
      <description>Zabbix template for Microsoft Windows Server. Tested on Microsoft Windows Server 2012, 2012 R2 and 2016. It may work with earlier versions, but some items (with missing performance counters) may be unsupported. Tested on Zabbix 3.4.0. It may work with earlier versions, but some items (for example service.info[service,&lt;param>]) may be unsupported. Mantas Tumenas. mantas.tumenas@gmail.com</description>
      <groups>
        <group>
          <name>Templates</name>
        </group>
      </groups>
      <applications>
        <application>
          <name>CPU</name>
        </application>
        <application>
          <name>Disk</name>
        </application>
        <application>
          <name>Disk Performance</name>
        </application>
        <application>
          <name>Memory</name>
        </application>
        <application>
          <name>Memory Performance</name>
        </application>
        <application>
          <name>Operating System</name>
        </application>
        <application>
          <name>Processor Performance</name>
        </application>
        <application>
          <name>Process Performance</name>
        </application>
        <application>
          <name>Services</name>
        </application>
        <application>
          <name>System Performance</name>
        </application>
      </applications>
      <items>
        <item>
          <name>Memory % Committed Bytes in Use</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Memory\% Committed Bytes in Use",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>This measures the ratio of Committed Bytes to the Commit Limit—in other words, the amount of virtual memory in use. This indicates insufficient memory if the number is greater than 80 percent. The obvious solution for this is to add more memory. Threshold: > 80%.</description>
          <applications>
            <application>
              <name>Memory Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>80</expression>
              <name>{HOST.NAME}: Memory % Committed Bytes in Use avg value > 80 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>WARNING</priority>
              <description>This measures the ratio of Committed Bytes to the Commit Limit—in other words, the amount of virtual memory in use. This indicates insufficient memory if the number is greater than 80 percent. The obvious solution for this is to add more memory. Threshold: > 80%.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Memory Cache Bytes</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Memory\Cache Bytes",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>B</units>
          <description>This indicates the amount of memory being used for the file system cache. Threshold: There may be a disk bottleneck if this value is greater than 300 MB.</description>
          <applications>
            <application>
              <name>Memory Performance</name>
            </application>
          </applications>
        </item>
        <item>
          <name>Memory Free System Page Table Entries</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Memory\Free System Page Table Entries",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Free System Page Table Entries is the number of page table entries not currently in used by the system. This analysis determines if the system is running out of free system page table entries (PTEs) by checking if there is less than 5,000 free PTE’s with a Warning if there is less than 10,000 free PTE’s. Lack of enough PTEs can result in system wide hang. Threshold: Running low on PTE’s – less than 10,000 (If the free PTEs are under 10,000 the system is close to a system wide hang). Critically low on PTE’s – less than 5000 (If the free PTEs are under 5000 the system is close to a system wide hang).</description>
          <applications>
            <application>
              <name>Memory Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}&lt;5000</expression>
              <name>{HOST.NAME}: Memory Free System Page Table Entries avg value &lt; 5000 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>HIGH</priority>
              <description>Free System Page Table Entries is the number of page table entries not currently in used by the system. This analysis determines if the system is running out of free system page table entries (PTEs) by checking if there is less than 5,000 free PTE’s with a Warning if there is less than 10,000 free PTE’s. Lack of enough PTEs can result in system wide hang. Threshold: Critically low on PTE’s – less than 5000 (If the free PTEs are under 5000 the system is close to a system wide hang).</description>
              <manual_close>YES</manual_close>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}&lt;10000</expression>
              <name>{HOST.NAME}: Memory Free System Page Table Entries avg value &lt; 10000 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>AVERAGE</priority>
              <description>Free System Page Table Entries is the number of page table entries not currently in used by the system. This analysis determines if the system is running out of free system page table entries (PTEs) by checking if there is less than 5,000 free PTE’s with a Warning if there is less than 10,000 free PTE’s. Lack of enough PTEs can result in system wide hang. Threshold: Running low on PTE’s – less than 10,000 (If the free PTEs are under 10,000 the system is close to a system wide hang).</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Memory Free System Page Table Entries avg value &lt; 5000 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\Memory\Free System Page Table Entries",1].avg(300,0)}&lt;5000</expression>
                </dependency>
              </dependencies>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Memory Pages/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Memory\Pages/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>/sec</units>
          <description>If it is high, then the system is likely running out of memory by trying to page the memory to the disk. Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files. Threshold: High pages/sec – greater than 1000 (If it’s higher than 1000, the system is could be beginning to run out of memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory). Very high average pages/sec – greater than 2500 (If this is greater than 2500, the system could be experiencing system-wide delays due to insufficient memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory). Critically high average pages/sec – greater than 5000 (If this is greater than 5000. If so, the system is most likely experiencing delays due to insufficient memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory).</description>
          <applications>
            <application>
              <name>Memory Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>1000</expression>
              <name>{HOST.NAME}: Memory Pages/sec avg value > 1000 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>INFO</priority>
              <description>If it is high, then the system is likely running out of memory by trying to page the memory to the disk. Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files. Threshold: High pages/sec – greater than 1000 (If it’s higher than 1000, the system is could be beginning to run out of memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory).</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Memory Pages/sec avg value > 2500 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\Memory\Pages/sec",1].avg(300,0)}>2500</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>2500</expression>
              <name>{HOST.NAME}: Memory Pages/sec avg value > 2500 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>WARNING</priority>
              <description>If it is high, then the system is likely running out of memory by trying to page the memory to the disk. Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files. Threshold: Very high average pages/sec – greater than 2500 (If this is greater than 2500, the system could be experiencing system-wide delays due to insufficient memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory).</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Memory Pages/sec avg value > 5000 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\Memory\Pages/sec",1].avg(300,0)}>5000</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>5000</expression>
              <name>{HOST.NAME}: Memory Pages/sec avg value > 5000 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>AVERAGE</priority>
              <description>If it is high, then the system is likely running out of memory by trying to page the memory to the disk. Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files. Threshold: Critically high average pages/sec – greater than 5000 (If this is greater than 5000. If so, the system is most likely experiencing delays due to insufficient memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory).</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Memory Pages Input/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Memory\Pages Input/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>/sec</units>
          <description>Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation. Threshold: More then 10 page file reads per second.</description>
          <applications>
            <application>
              <name>Memory Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>10</expression>
              <name>{HOST.NAME}: Memory Pages Input/sec avg value > 10 in the last 5 min</name>
              <url>http://technet.microsoft.com/en-us/magazine/2008.08.pulse.aspx</url>
              <priority>INFO</priority>
              <description>Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation. Threshold: More then 10 page file reads per second.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>PhysicalDisk % Disk Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\PhysicalDisk(_Total)\% Disk Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>Represents the percentage of elapsed time that the selected disk drive was busy servicing read or write requests. Threshold: greater than 50%, it represents an I/O bottleneck. Symptoms. Third-party monitoring tool may generate multiple alarm events during times when your disk is very busy. If you monitor the Physical %Disk Time on your Windows based computer, you may note that the value may go over 100% if your computer is very busy. For example, this could occur if you are copying a large amount of files, or you are copying multiple large files, and so on. Cause. This behavior can occur because some controllers allow the operating system to use overlapping input/output operations for multiple outstanding requests. The disk performance counters time the responses by using a 100 nanosecond precision counter, and then report the cumulative statistics for a given sample time. This sample time could go over 100% if, for example, you have 10 requests that completed in 2 milliseconds each in a 10 millisecond sampling interval. If you have multiple disks in a Raid arrangement, the overlapped input/output happens because the operating system can read and write to multiple disks, and this could show values that are higher than 100% for this counter. Status. This behavior is by design.</description>
          <applications>
            <application>
              <name>Disk Performance</name>
            </application>
          </applications>
        </item>
        <item>
          <name>PhysicalDisk % Idle Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\PhysicalDisk(_Total)\% Idle Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>This measures the percentage of time the disk was idle during the sample interval. Threshold: If this counter falls below 20%, the disk system is saturated. You may consider replacing the current disk system with a faster disk system.</description>
          <applications>
            <application>
              <name>Disk Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}&lt;20</expression>
              <name>{HOST.NAME}: PhysicalDisk % Idle Time avg value &lt; 20 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>INFO</priority>
              <description>This measures the percentage of time the disk was idle during the sample interval. If this counter falls below 20 percent, the disk system is saturated. You may consider replacing the current disk system with a faster disk system. Threshold: &lt; 20%.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>PhysicalDisk Avg. Disk Queue Length</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\PhysicalDisk(_Total)\Avg. Disk Queue Length",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>This indicates how many I/O operations are waiting for the hard drive to become available. Threshold: If the value here is larger than the two times the number of spindles, that means the disk itself may be the bottleneck.</description>
          <applications>
            <application>
              <name>Disk Performance</name>
            </application>
          </applications>
        </item>
        <item>
          <name>PhysicalDisk Avg. Disk sec/Read</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\PhysicalDisk(_Total)\Avg. Disk sec/Read",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>sec</units>
          <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms. Average disk responsiveness is very slow – more than 25 ms. Disk responsiveness is critical - more than 50 ms.</description>
          <applications>
            <application>
              <name>Disk Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>0.015</expression>
              <name>{HOST.NAME}: PhysicalDisk Read Latency avg value > 0.015 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>INFO</priority>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: PhysicalDisk Read Latency avg value > 0.025 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\PhysicalDisk(_Total)\Avg. Disk sec/Read",1].avg(300,0)}>0.025</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>0.025</expression>
              <name>{HOST.NAME}: PhysicalDisk Read Latency avg value > 0.025 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>WARNING</priority>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is very slow – more than 25 ms.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: PhysicalDisk Read Latency avg value > 0.050 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\PhysicalDisk(_Total)\Avg. Disk sec/Read",1].avg(300,0)}>0.050</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>0.050</expression>
              <name>{HOST.NAME}: PhysicalDisk Read Latency avg value > 0.050 in the last 5 min</name>
              <priority>AVERAGE</priority>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Disk responsiveness is critical - more than 50 ms.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>PhysicalDisk Avg. Disk sec/Write</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\PhysicalDisk(_Total)\Avg. Disk sec/Write",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>sec</units>
          <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms. Average disk responsiveness is very slow – more than 25 ms. Disk responsiveness is critical - more than 50 ms.</description>
          <applications>
            <application>
              <name>Disk Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>0.015</expression>
              <name>{HOST.NAME}: PhysicalDisk Write Latency avg value > 0.015 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>INFO</priority>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: PhysicalDisk Write Latency avg value > 0.025 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\PhysicalDisk(_Total)\Avg. Disk sec/Write",1].avg(300,0)}>0.025</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>0.025</expression>
              <name>{HOST.NAME}: PhysicalDisk Write Latency avg value > 0.025 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>WARNING</priority>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is very slow – more than 25 ms.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: PhysicalDisk Write Latency avg value > 0.050 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\PhysicalDisk(_Total)\Avg. Disk sec/Write",1].avg(300,0)}>0.050</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>0.050</expression>
              <name>{HOST.NAME}: PhysicalDisk Write Latency avg value > 0.050 in the last 5 min</name>
              <priority>AVERAGE</priority>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is critical - more than 50 ms.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>IO Data Operations/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Process(_Total)\IO Data Operations/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>O/sec</units>
          <description>These counters count all I/O activity generated to include file, network and device I/Os. These analyses check when processes are doing more than 1,000 I/O’s per second and flag it as a warning. These analyses are best used in correlation with other analyses such as disk analysis to determine which processes might be involved in the I/O activity.</description>
          <applications>
            <application>
              <name>Process Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>1000</expression>
              <name>{HOST.NAME}: Process IO Data Operations/sec avg value > 1000 in the last 5 min</name>
              <priority>INFO</priority>
              <description>These counters count all I/O activity generated to include file, network and device I/Os. These analyses check when processes are doing more than 1,000 I/O’s per second and flag it as a warning. These analyses are best used in correlation with other analyses such as disk analysis to determine which processes might be involved in the I/O activity.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>IO Other Operations/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Process(_Total)\IO Other Operations/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>O/sec</units>
          <description>The number of input/output operations generated by a process that are neither reads nor writes, including file, network, and device I/Os. An example of this type of operation would be a control function. I/O Others directed to CONSOLE (console input object) handles are not counted. These analyses check when processes are doing more than 1,000 I/O’s per second and flag it as a warning.</description>
          <applications>
            <application>
              <name>Process Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>1000</expression>
              <name>{HOST.NAME}: Process IO Other Operations/sec avg value > 1000 in the last 5 min</name>
              <priority>INFO</priority>
              <description>The number of input/output operations generated by a process that are neither reads nor writes, including file, network, and device I/Os. An example of this type of operation would be a control function. I/O Others directed to CONSOLE (console input object) handles are not counted. These analyses check when processes are doing more than 1,000 I/O’s per second and flag it as a warning.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>IO Read Operations/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Process(_Total)\IO Read Operations/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>O/sec</units>
          <description>The number of read input/output operations generated by a process, including file, network, and device I/Os. I/O Reads directed to CONSOLE (console input object) handles are not counted.</description>
          <applications>
            <application>
              <name>Process Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>1000</expression>
              <name>{HOST.NAME}: Process IO Read Operations/sec avg value > 1000 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>INFO</priority>
              <description>The number of read input/output operations generated by a process, including file, network, and device I/Os. I/O Reads directed to CONSOLE (console input object) handles are not counted.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>IO Write Operations/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Process(_Total)\IO Write Operations/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>O/sec</units>
          <description>The number of write input/output operations generated by a process, including file, network, and device I/Os. I/O Writes directed to CONSOLE (console input object) handles are not counted.</description>
          <applications>
            <application>
              <name>Process Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>1000</expression>
              <name>{HOST.NAME}: Process IO Write Operations/sec avg value > 1000 in the last 5 min</name>
              <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
              <priority>INFO</priority>
              <description>The number of write input/output operations generated by a process, including file, network, and device I/Os. I/O Writes directed to CONSOLE (console input object) handles are not counted.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Processor % DPC Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Processor Information(_Total)\% DPC Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>Determines how much time the processor is spending processing DPCs. DPCs originate when the processor performs tasks requiring immediate attention, and then defers the remainder of the task to be handled at lower priority. DPCs represent further processing of client requests. Threshold: 40%.</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>40</expression>
              <name>{HOST.NAME}: Processor % DPC Time avg value > 40% in the last 5 min</name>
              <priority>INFO</priority>
              <description>Determines how much time the processor is spending processing DPCs. DPCs originate when the processor performs tasks requiring immediate attention, and then defers the remainder of the task to be handled at lower priority. DPCs represent further processing of client requests. Threshold: 40%.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Processor % Interrupt Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Processor Information(_Total)\% Interrupt Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>This counter indicates the percentage of time the processor spends receiving and servicing hardware interrupts. This value is an indirect indicator of the activity of devices that generate interrupts, such as network adapters. A dramatic increase in this counter indicates potential hardware problems. Threshold: High CPU Interrupt Time – more than 30% interrupt time (A high amount of % Interrupt Time in the processor could indicate a hardware or driver problem). Very high CPU Interrupt Time – more than 50% interrupt time (A very high amount of % Interrupt Time in the processor could indicate a hardware or driver problem.</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>30</expression>
              <name>{HOST.NAME}: Processor % Interrupt Time avg value > 30% in the last 5 min</name>
              <description>This counter indicates the percentage of time the processor spends receiving and servicing hardware interrupts. This value is an indirect indicator of the activity of devices that generate interrupts, such as network adapters. A dramatic increase in this counter indicates potential hardware problems. Threshold: High CPU Interrupt Time – more than 30% interrupt time (A high amount of % Interrupt Time in the processor could indicate a hardware or driver problem).</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Processor % Interrupt Time avg value > 50% in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\Processor Information(_Total)\% Interrupt Time",1].avg(300,0)}>50</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>50</expression>
              <name>{HOST.NAME}: Processor % Interrupt Time avg value > 50% in the last 5 min</name>
              <priority>INFO</priority>
              <description>This counter indicates the percentage of time the processor spends receiving and servicing hardware interrupts. This value is an indirect indicator of the activity of devices that generate interrupts, such as network adapters. A dramatic increase in this counter indicates potential hardware problems. Threshold: Very high CPU Interrupt Time – more than 50 % interrupt time (A very high amount of % Interrupt Time in the processor could indicate a hardware or driver problem.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Processor % Privileged Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Processor Information(_Total)\% Privileged Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>This counter indicates the percentage of time a thread runs in privileged mode. When your application calls operating system functions (for example to perform file or network I/O or to allocate memory), these operating system functions are executed in privileged mode. Threshold: A figure that is consistently over 75% indicates a bottleneck.</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>75</expression>
              <name>{HOST.NAME}: Processor % Privileged Time avg value > 75% in the last 5 min</name>
              <description>This counter indicates the percentage of time a thread runs in privileged mode. When your application calls operating system functions (for example to perform file or network I/O or to allocate memory), these operating system functions are executed in privileged mode. Threshold: A figure that is consistently over 75% indicates a bottleneck.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Processor % Processor Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Processor Information(_Total)\% Processor Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>This measures the percentage of elapsed time the processor spends executing a non-idle thread. If the percentage is greater than 85 percent, the processor is overwhelmed and the server may require a faster processor. This counter is the primary indicator of processor activity. High values many not necessarily be bad. However, if the other processor-related counters are increasing linearly such as % Privileged Time or Processor Queue Length, high CPU utilization may be worth investigating). Threshold: 60% - Warning. 85% - Average. 95% - Critical.</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(900,0)}>60</expression>
              <name>{HOST.NAME}: Processor % Processor Time avg value > 60 % in the last 15 min</name>
              <priority>INFO</priority>
              <description>This measures the percentage of elapsed time the processor spends executing a non-idle thread. If the percentage is greater than 85 percent, the processor is overwhelmed and the server may require a faster processor. This counter is the primary indicator of processor activity. High values many not necessarily be bad. However, if the other processor-related counters are increasing linearly such as % Privileged Time or Processor Queue Length, high CPU utilization may be worth investigating). Threshold: 60% - Warning.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Processor % Processor Time avg value > 85% in the last 15 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\Processor Information(_Total)\% Processor Time",1].avg(900,0)}>85</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(900,0)}>85</expression>
              <name>{HOST.NAME}: Processor % Processor Time avg value > 85% in the last 15 min</name>
              <priority>WARNING</priority>
              <description>This measures the percentage of elapsed time the processor spends executing a non-idle thread. If the percentage is greater than 85 percent, the processor is overwhelmed and the server may require a faster processor. This counter is the primary indicator of processor activity. High values many not necessarily be bad. However, if the other processor-related counters are increasing linearly such as % Privileged Time or Processor Queue Length, high CPU utilization may be worth investigating). Threshold: 85% - Average.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Processor % Processor Time avg value > 95% in the last 15 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\Processor Information(_Total)\% Processor Time",1].avg(900,0)}>95</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(900,0)}>95</expression>
              <name>{HOST.NAME}: Processor % Processor Time avg value > 95% in the last 15 min</name>
              <priority>AVERAGE</priority>
              <description>This measures the percentage of elapsed time the processor spends executing a non-idle thread. If the percentage is greater than 85 percent, the processor is overwhelmed and the server may require a faster processor. This counter is the primary indicator of processor activity. High values many not necessarily be bad. However, if the other processor-related counters are increasing linearly such as % Privileged Time or Processor Queue Length, high CPU utilization may be worth investigating). Threshold: 95% - Critical.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Processor % User Time</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Processor Information(_Total)\% User Time",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>This measures the percentage of elapsed time the processor spends in user mode. If this value is high, the server is busy with the application. One possible solution here is to optimize the application that is using up the processor resources. Threshold: Depends on the scenario. Expect 20–30% of processor time in a user-mode scenario like Web Proxy. Suspect more than 70% of % Processor Time unless using SSL or VPN.</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>70</expression>
              <name>{HOST.NAME}: Processor % User Time avg value > 70% in the last 5 min</name>
              <priority>INFO</priority>
              <description>This measures the percentage of elapsed time the processor spends in user mode. If this value is high, the server is busy with the application. One possible solution here is to optimize the application that is using up the processor resources. Threshold: Depends on the scenario. Expect 20–30% of processor time in a user-mode scenario like Web Proxy. Suspect more than 70% of % Processor Time unless using SSL or VPN.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Server Work Queues</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\Server Work Queues(*)\Queue Length",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Shows the current length of the server work queue for this CPU. Threshold: A sustained queue length greater than four might indicate processor congestion. This is an instantaneous count, not an average over time.</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>4</expression>
              <name>{HOST.NAME}: Server Work Queues avg value > 4 in the last 5 min</name>
              <priority>INFO</priority>
              <description>Shows the current length of the server work queue for this CPU. Threshold: A sustained queue length greater than four might indicate processor congestion. This is an instantaneous count, not an average over time.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>System % Registry Quota In Use</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\System\% Registry Quota In Use",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>% Registry Quota In Use is the percentage of the Total Registry Quota Allowed that is currently being used by the system. This counter displays the current percentage value only; it is not an average. Threshold: Average - 60%. High - 85%.</description>
          <applications>
            <application>
              <name>System Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>60</expression>
              <name>{HOST.NAME}: % registry Quota in Use {ITEM.LASTVALUE}</name>
              <priority>AVERAGE</priority>
              <description>% Registry Quota In Use is the percentage of the Total Registry Quota Allowed that is currently being used by the system. This counter displays the current percentage value only; it is not an average. Threshold: > 60%.</description>
              <manual_close>YES</manual_close>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>85</expression>
              <name>{HOST.NAME}: % registry Quota in Use {ITEM.LASTVALUE}</name>
              <priority>HIGH</priority>
              <description>% Registry Quota In Use is the percentage of the Total Registry Quota Allowed that is currently being used by the system. This counter displays the current percentage value only, it is not an average. Threshold: High - 85%.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>System Context Switches/sec</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\System\Context Switches/sec",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>S/sec</units>
          <description>Indicates that the kernel has switched the thread it is running on a processor. A context switch occurs each time a new thread runs, and each time one thread takes over from another. A large number of threads is likely to increase the number of context switches. Context switches allow multiple threads to share time slices on the processors, but they also interrupt the processor and might reduce overall system performance, especially on multiprocessor computers. You should also observe the patterns of context switches over time. Threshold: High context switches/sec – more than 5000 context switches per second. Very high context switches/sec – more than 10,000 context switches per second.</description>
          <applications>
            <application>
              <name>System Performance</name>
            </application>
          </applications>
        </item>
        <item>
          <name>Processor Queue Length</name>
          <type>ZABBIX_ACTIVE</type>
          <key>perf_counter["\System\Processor Queue Length",1]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>If there are more tasks ready to run than there are processors, threads queue up. The processor queue is the collection of threads that are ready but not able to be executed by the processor because another active thread is currently executing. A sustained or recurring queue of more than two threads is a clear indication of a processor bottleneck. You may get more throughput by reducing parallelism in those cases. You can use this counter in conjunction with the Processor\% Processor Time counter to determine if your application can benefit from more CPUs. There is a single queue for processor time, even on multiprocessor computers. Therefore, in a multiprocessor computer, divide the Processor Queue Length (PQL) value by the number of processors servicing the workload. If the CPU is very busy (90 percent and higher utilization) and the PQL average is consistently higher than 2 per processor, you may have a processor bottleneck that could benefit from additional CPUs. Or, you could reduce the number of threads and queue more at the application level. This will cause less context switching, and less context switching is good for reducing CPU load. The common reason for a PQL of 2 or higher with low CPU utilization is that requests for processor time arrive randomly and threads demand irregular amounts of time from the processor. This means that the processor is not a bottleneck but that it is your threading logic that needs to be improved. Threshold: Average - each processor has 10 or more threads waiting.(Determines if the average processor queue length exceeds the number of processors by 10. If this threshold is broken, then the processor(s) may be at capacity). High - each processor has 20 or more threads waiting(Determines if the average processor queue length exceeds twenty times the number of processors. If this threshold is broken, then the processor(s) are beyond capacity).</description>
          <applications>
            <application>
              <name>Processor Performance</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{avg(300,0)}>10</expression>
              <name>{HOST.NAME}: Processor Queue Length avg value > 10 in the last 5 min</name>
              <priority>INFO</priority>
              <description>If there are more tasks ready to run than there are processors, threads queue up. The processor queue is the collection of threads that are ready but not able to be executed by the processor because another active thread is currently executing. A sustained or recurring queue of more than two threads is a clear indication of a processor bottleneck. You may get more throughput by reducing parallelism in those cases. You can use this counter in conjunction with the Processor\% Processor Time counter to determine if your application can benefit from more CPUs. There is a single queue for processor time, even on multiprocessor computers. Therefore, in a multiprocessor computer, divide the Processor Queue Length (PQL) value by the number of processors servicing the workload. If the CPU is very busy (90 percent and higher utilization) and the PQL average is consistently higher than 2 per processor, you may have a processor bottleneck that could benefit from additional CPUs. Or, you could reduce the number of threads and queue more at the application level. This will cause less context switching, and less context switching is good for reducing CPU load. The common reason for a PQL of 2 or higher with low CPU utilization is that requests for processor time arrive randomly and threads demand irregular amounts of time from the processor. This means that the processor is not a bottleneck but that it is your threading logic that needs to be improved. Threshold: Average - each processor has 10 or more threads waiting.(Determines if the average processor queue length exceeds the number of processors by 10. If this threshold is broken, then the processor(s) may be at capacity).</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Processor Queue Length avg value > 20 in the last 5 min</name>
                  <expression>{OS Windows Server Baseline:perf_counter["\System\Processor Queue Length",1].avg(300,0)}>20</expression>
                </dependency>
              </dependencies>
            </trigger>
            <trigger>
              <expression>{avg(300,0)}>20</expression>
              <name>{HOST.NAME}: Processor Queue Length avg value > 20 in the last 5 min</name>
              <priority>WARNING</priority>
              <description>If there are more tasks ready to run than there are processors, threads queue up. The processor queue is the collection of threads that are ready but not able to be executed by the processor because another active thread is currently executing. A sustained or recurring queue of more than two threads is a clear indication of a processor bottleneck. You may get more throughput by reducing parallelism in those cases. You can use this counter in conjunction with the Processor\% Processor Time counter to determine if your application can benefit from more CPUs. There is a single queue for processor time, even on multiprocessor computers. Therefore, in a multiprocessor computer, divide the Processor Queue Length (PQL) value by the number of processors servicing the workload. If the CPU is very busy (90 percent and higher utilization) and the PQL average is consistently higher than 2 per processor, you may have a processor bottleneck that could benefit from additional CPUs. Or, you could reduce the number of threads and queue more at the application level. This will cause less context switching, and less context switching is good for reducing CPU load. The common reason for a PQL of 2 or higher with low CPU utilization is that requests for processor time arrive randomly and threads demand irregular amounts of time from the processor. This means that the processor is not a bottleneck but that it is your threading logic that needs to be improved. Threshold: High - each processor has 20 or more threads waiting(Determines if the average processor queue length exceeds twenty times the number of processors. If this threshold is broken, then the processor(s) are beyond capacity).</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service DNS Client</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[Dnscache]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>The DNS Client service (dnscache) caches Domain Name System (DNS) names and registers the full computer name for this computer. If the service is stopped, DNS names will continue to be resolved. However, the results of DNS name queries will not be cached and the computer's name will not be registered. If the service is disabled, any services that explicitly depend on it will fail to start.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service DNS Cache {ITEM.LASTVALUE}</name>
              <description>The DNS Client service (dnscache) caches Domain Name System (DNS) names and registers the full computer name for this computer. If the service is stopped, DNS names will continue to be resolved. However, the results of DNS name queries will not be cached and the computer's name will not be registered. If the service is disabled, any services that explicitly depend on it will fail to start.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Event Log</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[eventlog]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>This service manages events and event logs. It supports logging events, querying events, subscribing to events, archiving event logs, and managing event metadata. It can display events in both XML and plain text format. Stopping this service may compromise security and reliability of the system.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Event Log {ITEM.LASTVALUE}</name>
              <description>This service manages events and event logs. It supports logging events, querying events, subscribing to events, archiving event logs, and managing event metadata. It can display events in both XML and plain text format. Stopping this service may compromise security and reliability of the system.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Group Policy Client</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[gpsvc]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>The service is responsible for applying settings configured by administrators for the computer and users through the Group Policy component. If the service is stopped or disabled, the settings will not be applied and applications and components will not be manageable through Group Policy. Any components or applications that depend on the Group Policy component might not be functional if the service is stopped or disabled.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Group Policy Client {ITEM.LASTVALUE}</name>
              <description>The service is responsible for applying settings configured by administrators for the computer and users through the Group Policy component. If the service is stopped or disabled, the settings will not be applied and applications and components will not be manageable through Group Policy. Any components or applications that depend on the Group Policy component might not be functional if the service is stopped or disabled.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Server</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[LanmanServer]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Supports file, print, and named-pipe sharing over the network for this computer. If this service is stopped, these functions will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Server {ITEM.LASTVALUE}</name>
              <description>Supports file, print, and named-pipe sharing over the network for this computer. If this service is stopped, these functions will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Workstation</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[LanManWorkstation]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Creates and maintains client network connections to remote servers using the SMB protocol. If this service is stopped, these connections will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Workstation {ITEM.LASTVALUE}</name>
              <description>Creates and maintains client network connections to remote servers using the SMB protocol. If this service is stopped, these connections will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Windows Firewall</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[MpsSvc]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Windows Firewall helps protect your computer by preventing unauthorized users from gaining access to your computer through the Internet or a network.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Windows Firewall {ITEM.LASTVALUE}</name>
              <description>Windows Firewall helps protect your computer by preventing unauthorized users from gaining access to your computer through the Internet or a network.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Network List Service</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[netprofm]</key>
          <delay>30s</delay>
          <description>Identifies the networks to which the computer has connected, collects and stores properties for these networks, and notifies applications when these properties change.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Network List {ITEM.LASTVALUE}</name>
              <description>Identifies the networks to which the computer has connected, collects and stores properties for these networks, and notifies applications when these properties change.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Network Location Awareness</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[nlasvc]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Collects and stores configuration information for the network and notifies programs when this information is modified. If this service is stopped, configuration information might be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Network Location Awareness {ITEM.LASTVALUE}</name>
              <description>Collects and stores configuration information for the network and notifies programs when this information is modified. If this service is stopped, configuration information might be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service RPC Endpoint Mapper</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[RpcEptMapper]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>Resolves RPC interfaces identifiers to transport endpoints. If this service is stopped or disabled, programs using Remote Procedure Call (RPC) services will not function properly.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service RPC Endpoint Mapper {ITEM.LASTVALUE}</name>
              <description>Resolves RPC interfaces identifiers to transport endpoints. If this service is stopped or disabled, programs using Remote Procedure Call (RPC) services will not function properly.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Service Security Account Manager</name>
          <type>ZABBIX_ACTIVE</type>
          <key>service_state[SamSs]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <description>The start up of this service signals other services that the Security Accounts Manager (SAM) is ready to accept requests. Disabling this service will prevent other services in the system from being notified when the SAM is ready, which may in turn cause those services to fail to start correctly. This service should not be disabled.</description>
          <applications>
            <application>
              <name>Services</name>
            </application>
          </applications>
          <valuemap>
            <name>Windows service state</name>
          </valuemap>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;>0</expression>
              <name>{HOST.NAME}: Service Security Account Manager {ITEM.LASTVALUE}</name>
              <description>The startup of this service signals other services that the Security Accounts Manager (SAM) is ready to accept requests. Disabling this service will prevent other services in the system from being notified when the SAM is ready, which may in turn cause those services to fail to start correctly. This service should not be disabled.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Number of CPUs online</name>
          <type>ZABBIX_ACTIVE</type>
          <key>system.cpu.num[online]</key>
          <delay>1h</delay>
          <description>Number of CPUs online.</description>
          <applications>
            <application>
              <name>CPU</name>
            </application>
          </applications>
        </item>
        <item>
          <name>System uptime</name>
          <type>ZABBIX_ACTIVE</type>
          <key>system.uptime</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>s</units>
          <description>System uptime in seconds.</description>
          <applications>
            <application>
              <name>Operating System</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{change(0)}&lt;0</expression>
              <name>{HOST.NAME} has just been restarted</name>
              <priority>INFO</priority>
              <description>Server has just been restarted.</description>
              <manual_close>YES</manual_close>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Memory Available</name>
          <type>ZABBIX_ACTIVE</type>
          <key>vm.memory.size[available]</key>
          <delay>30s</delay>
          <units>B</units>
          <description>Inactive + Cached + Free memory. Threshold: Low on available memory – less than 10% available. Very low on available memory – less than 5% available. Decreasing trend of 10 MB’s per hour. This could indicate a memory leak.</description>
          <applications>
            <application>
              <name>Memory</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;100</expression>
              <name>{HOST.NAME}: Memory Available {ITEM.LASTVALUE}</name>
              <priority>AVERAGE</priority>
              <description>Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. The Virtual Memory Manager continually adjusts the space used in physical memory and on disk to maintain a minimum number of available bytes for the operating system and processes. When available bytes are plentiful, the Virtual Memory Manager lets the working sets of processes grow, or keeps them stable by removing an old page for each new page added. When available bytes are few, the Virtual Memory Manager must trim the working sets of processes to maintain the minimum required. Threshold: Low on available memory – less than 10% available. Very low on available memory – less than 5% available. Decreasing trend of 10 MB’s per hour. This could indicate a memory leak.</description>
              <manual_close>YES</manual_close>
            </trigger>
            <trigger>
              <expression>{last(,0)}&lt;300</expression>
              <name>{HOST.NAME}: Memory Available {ITEM.LASTVALUE}</name>
              <priority>WARNING</priority>
              <description>Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. The Virtual Memory Manager continually adjusts the space used in physical memory and on disk to maintain a minimum number of available bytes for the operating system and processes. When available bytes are plentiful, the Virtual Memory Manager lets the working sets of processes grow, or keeps them stable by removing an old page for each new page added. When available bytes are few, the Virtual Memory Manager must trim the working sets of processes to maintain the minimum required. Threshold: Low on available memory – less than 10% available. Very low on available memory – less than 5% available. Decreasing trend of 10 MB’s per hour. This could indicate a memory leak.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Memory Available {ITEM.LASTVALUE}</name>
                  <expression>{OS Windows Server Baseline:vm.memory.size[available].last(,0)}&lt;100</expression>
                </dependency>
              </dependencies>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Memory Cached</name>
          <type>ZABBIX_ACTIVE</type>
          <key>vm.memory.size[cached]</key>
          <delay>30s</delay>
          <units>B</units>
          <description>Memory Cached.</description>
          <applications>
            <application>
              <name>Memory</name>
            </application>
          </applications>
        </item>
        <item>
          <name>Memory Available %</name>
          <type>ZABBIX_ACTIVE</type>
          <key>vm.memory.size[pavailable]</key>
          <delay>30s</delay>
          <value_type>FLOAT</value_type>
          <units>%</units>
          <description>Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. The Virtual Memory Manager continually adjusts the space used in physical memory and on disk to maintain a minimum number of available bytes for the operating system and processes. When available bytes are plentiful, the Virtual Memory Manager lets the working sets of processes grow, or keeps them stable by removing an old page for each new page added. When available bytes are few, the Virtual Memory Manager must trim the working sets of processes to maintain the minimum required. Threshold: Low on available memory – less than 10% available. Very low on available memory – less than 5% available. Decreasing trend of 10 MB’s per hour. This could indicate a memory leak.</description>
          <applications>
            <application>
              <name>Memory</name>
            </application>
          </applications>
          <triggers>
            <trigger>
              <expression>{last(,0)}&lt;3</expression>
              <name>{HOST.NAME}: Memory Available percentage {ITEM.LASTVALUE}</name>
              <priority>AVERAGE</priority>
              <description>Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. The Virtual Memory Manager continually adjusts the space used in physical memory and on disk to maintain a minimum number of available bytes for the operating system and processes. When available bytes are plentiful, the Virtual Memory Manager lets the working sets of processes grow, or keeps them stable by removing an old page for each new page added. When available bytes are few, the Virtual Memory Manager must trim the working sets of processes to maintain the minimum required. Threshold: Low on available memory – less than 10% available. Very low on available memory – less than 5% available. Decreasing trend of 10 MB’s per hour. This could indicate a memory leak.</description>
              <manual_close>YES</manual_close>
            </trigger>
            <trigger>
              <expression>{last(,0)}&lt;5</expression>
              <name>{HOST.NAME}: Memory Available percentage {ITEM.LASTVALUE}</name>
              <priority>WARNING</priority>
              <description>Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. The Virtual Memory Manager continually adjusts the space used in physical memory and on disk to maintain a minimum number of available bytes for the operating system and processes. When available bytes are plentiful, the Virtual Memory Manager lets the working sets of processes grow, or keeps them stable by removing an old page for each new page added. When available bytes are few, the Virtual Memory Manager must trim the working sets of processes to maintain the minimum required. Threshold: Low on available memory – less than 10% available. Very low on available memory – less than 5% available. Decreasing trend of 10 MB’s per hour. This could indicate a memory leak.</description>
              <manual_close>YES</manual_close>
              <dependencies>
                <dependency>
                  <name>{HOST.NAME}: Memory Available percentage {ITEM.LASTVALUE}</name>
                  <expression>{OS Windows Server Baseline:vm.memory.size[pavailable].last(,0)}&lt;3</expression>
                </dependency>
              </dependencies>
            </trigger>
          </triggers>
        </item>
        <item>
          <name>Memory Total</name>
          <type>ZABBIX_ACTIVE</type>
          <key>vm.memory.size[total]</key>
          <delay>1h</delay>
          <units>B</units>
          <description>Memory Total.</description>
          <applications>
            <application>
              <name>Memory</name>
            </application>
          </applications>
        </item>
        <item>
          <name>Memory Size Used</name>
          <type>ZABBIX_ACTIVE</type>
          <key>vm.memory.size[used]</key>
          <delay>30s</delay>
          <units>B</units>
          <description>Memory Used.</description>
          <applications>
            <application>
              <name>Memory</name>
            </application>
          </applications>
        </item>
      </items>
      <discovery_rules>
        <discovery_rule>
          <name>CPUs discovery</name>
          <type>ZABBIX_ACTIVE</type>
          <key>system.cpu.discovery</key>
          <delay>1h</delay>
          <filter>
            <conditions>
              <condition>
                <macro>{#CPU.NUMBER}</macro>
                <value>^[0-9]+$</value>
                <formulaid>A</formulaid>
              </condition>
            </conditions>
          </filter>
          <lifetime>90d</lifetime>
          <description>Discovery of CPUs of different types as defined in global regular expression "CPU for discovery".</description>
          <item_prototypes>
            <item_prototype>
              <name>Processor No $1 Utilization % (1 min average)</name>
              <type>ZABBIX_ACTIVE</type>
              <key>system.cpu.util[{#CPU.NUMBER},system,avg1]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>%</units>
              <description>CPU utilization in percent.</description>
              <applications>
                <application>
                  <name>Processor Performance</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(600,0)}>90</expression>
                  <name>Processor {#CPU.NUMBER} utilization avg value > 90% in the last 1 min</name>
                  <priority>INFO</priority>
                  <description>CPU utilization in percent. Threshold: 90 % in the last 15 minutes.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>Processor {#CPU.NUMBER} utilization avg value > 90% in the last 5 min</name>
                      <expression>{OS Windows Server Baseline:system.cpu.util[{#CPU.NUMBER},system,avg5].avg(600,0)}>90</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>Processor No $1 Utilization % (5 min average)</name>
              <type>ZABBIX_ACTIVE</type>
              <key>system.cpu.util[{#CPU.NUMBER},system,avg5]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>%</units>
              <description>CPU utilization in percent.</description>
              <applications>
                <application>
                  <name>Processor Performance</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(600,0)}>90</expression>
                  <name>Processor {#CPU.NUMBER} utilization avg value > 90% in the last 5 min</name>
                  <priority>WARNING</priority>
                  <description>CPU utilization in percent. Threshold: 90 % in the last 15 minutes.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>Processor {#CPU.NUMBER} utilization avg value > 90% in the last 15 min</name>
                      <expression>{OS Windows Server Baseline:system.cpu.util[{#CPU.NUMBER},system,avg15].avg(600,0)}>90</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>Processor No $1 Utilization % (15 min average)</name>
              <type>ZABBIX_ACTIVE</type>
              <key>system.cpu.util[{#CPU.NUMBER},system,avg15]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>%</units>
              <description>CPU utilization in percent.</description>
              <applications>
                <application>
                  <name>Processor Performance</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(600,0)}>90</expression>
                  <name>Processor {#CPU.NUMBER} utilization avg value > 90% in the last 15 min</name>
                  <priority>AVERAGE</priority>
                  <description>CPU utilization in percent. Threshold: 90 % in the last 15 minutes.</description>
                  <manual_close>YES</manual_close>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
          </item_prototypes>
        </discovery_rule>
        <discovery_rule>
          <name>Mounted filesystem discovery</name>
          <type>ZABBIX_ACTIVE</type>
          <key>vfs.fs.discovery</key>
          <delay>1h</delay>
          <filter>
            <conditions>
              <condition>
                <macro>{#FSTYPE}</macro>
                <value>@File systems for discovery</value>
                <formulaid>A</formulaid>
              </condition>
            </conditions>
          </filter>
          <lifetime>90d</lifetime>
          <description>Discovery of file systems of different types as defined in global regular expression "File systems for discovery".</description>
          <item_prototypes>
            <item_prototype>
              <name>$1</name>
              <type>ZABBIX_ACTIVE</type>
              <key>perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Read",1]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>sec</units>
              <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms. Average disk responsiveness is very slow – more than 25 ms. Disk responsiveness is critical - more than 50 ms.</description>
              <applications>
                <application>
                  <name>Disk Performance</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(300,0)}>0.015</expression>
                  <name>{HOST.NAME}: LogicalDisk Read Latency avg value > 0.015 in the last 5 min</name>
                  <url>http://blogs.technet.com/b/askcore/archive/2012/03/16/windows-performance-monitor-disk-counters-explained.aspx</url>
                  <priority>INFO</priority>
                  <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>{HOST.NAME}: LogicalDisk Read Latency avg value > 0.025 in the last 5 min</name>
                      <expression>{OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Read",1].avg(300,0)}>0.025</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{avg(300,0)}>0.025</expression>
                  <name>{HOST.NAME}: LogicalDisk Read Latency avg value > 0.025 in the last 5 min</name>
                  <priority>WARNING</priority>
                  <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is very slow – more than 25 ms.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>{HOST.NAME}: LogicalDisk Read Latency avg value > 0.050 in the last 5 min</name>
                      <expression>{OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Read",1].avg(300,0)}>0.050</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{avg(300,0)}>0.050</expression>
                  <name>{HOST.NAME}: LogicalDisk Read Latency avg value > 0.050 in the last 5 min</name>
                  <priority>AVERAGE</priority>
                  <description>This measures the average time, in seconds, to read data from the disk. If the number is larger than 25 milliseconds (ms), that means the disk system is experiencing latency when reading from the disk. For mission-critical servers hosting SQL Server® and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The most logical solution here is to replace the current disk system with a faster disk system. Threshold: Average disk responsiveness is very slow – more than 25 ms.</description>
                  <manual_close>YES</manual_close>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>$1</name>
              <type>ZABBIX_ACTIVE</type>
              <key>perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Transfer",1]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>sec</units>
              <description>Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.</description>
              <applications>
                <application>
                  <name>Disk Performance</name>
                </application>
              </applications>
            </item_prototype>
            <item_prototype>
              <name>$1</name>
              <type>ZABBIX_ACTIVE</type>
              <key>perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Write",1]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>sec</units>
              <description>This measures the average time, in seconds, it takes to write data to the disk. If the number is larger than 25 ms, the disk system experiences latency when writing to the disk. For mission-critical servers hosting SQL Server and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The likely solution here is to replace the disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms. Average disk responsiveness is very slow – more than 25 ms. Disk responsiveness is critical - more than 50 ms.</description>
              <applications>
                <application>
                  <name>Disk Performance</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(300,0)}>0.015</expression>
                  <name>{HOST.NAME}: LogicalDisk WriteLatency avg value > 0.015 in the last 5 min</name>
                  <priority>INFO</priority>
                  <description>This measures the average time, in seconds, it takes to write data to the disk. If the number is larger than 25 ms, the disk system experiences latency when writing to the disk. For mission-critical servers hosting SQL Server and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The likely solution here is to replace the disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>{HOST.NAME}: LogicalDisk WriteLatency avg value > 0.025 in the last 5 min</name>
                      <expression>{OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Write",1].avg(300,0)}>0.025</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{avg(300,0)}>0.025</expression>
                  <name>{HOST.NAME}: LogicalDisk WriteLatency avg value > 0.025 in the last 5 min</name>
                  <priority>WARNING</priority>
                  <description>This measures the average time, in seconds, it takes to write data to the disk. If the number is larger than 25 ms, the disk system experiences latency when writing to the disk. For mission-critical servers hosting SQL Server and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The likely solution here is to replace the disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>{HOST.NAME}: LogicalDisk Write Latency avg value > 0.050 in the last 5 min</name>
                      <expression>{OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Write",1].avg(300,0)}>0.050</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{avg(300,0)}>0.050</expression>
                  <name>{HOST.NAME}: LogicalDisk Write Latency avg value > 0.050 in the last 5 min</name>
                  <priority>AVERAGE</priority>
                  <description>This measures the average time, in seconds, it takes to write data to the disk. If the number is larger than 25 ms, the disk system experiences latency when writing to the disk. For mission-critical servers hosting SQL Server and Exchange Server, the acceptable threshold is much lower, approximately 10 ms. The likely solution here is to replace the disk system with a faster disk system. Threshold: Average disk responsiveness is slow – more than 15 ms.</description>
                  <manual_close>YES</manual_close>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>$1</name>
              <type>ZABBIX_ACTIVE</type>
              <key>perf_counter["\LogicalDisk({#FSNAME})\Disk Transfers/sec",1]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>T/sec</units>
              <description>Disk Transfers/sec is the rate of read and write operations on the disk. Threshold: Less than 80 I/O’s per second on average when disk latency is longer than 25 ms. This may indicate too many virtual LUNs using the same physical disks on a SAN.</description>
              <applications>
                <application>
                  <name>Disk Performance</name>
                </application>
              </applications>
            </item_prototype>
            <item_prototype>
              <name>LogicalDisk Disk $1 Space Available</name>
              <type>ZABBIX_ACTIVE</type>
              <key>vfs.fs.size[{#FSNAME},free]</key>
              <delay>30s</delay>
              <units>B</units>
              <description>This measures the amount of free space on the selected logical disk drive.</description>
              <applications>
                <application>
                  <name>Disk</name>
                </application>
              </applications>
            </item_prototype>
            <item_prototype>
              <name>LogicalDisk Disk $1 Space Available %</name>
              <type>ZABBIX_ACTIVE</type>
              <key>vfs.fs.size[{#FSNAME},pfree]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>%</units>
              <description>This measures the percentage of free space on the selected logical disk drive. Threshold: If this falls below 15 percent, you risk running out of free space for the OS to store critical files.</description>
              <applications>
                <application>
                  <name>Disk</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{last(0)}&lt;3</expression>
                  <name>{HOST.NAME}: Free Disk {#FSNAME} Space {ITEM.LASTVALUE}</name>
                  <priority>AVERAGE</priority>
                  <description>This measures the percentage of free space on the selected logical disk drive. Threshold: If this falls below 15 percent, you risk running out of free space for the OS to store critical files.</description>
                  <manual_close>YES</manual_close>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{last(0)}&lt;5</expression>
                  <name>{HOST.NAME}: Free Disk {#FSNAME} Space {ITEM.LASTVALUE}</name>
                  <priority>WARNING</priority>
                  <description>This measures the percentage of free space on the selected logical disk drive. Threshold: If this falls below 15 percent, you risk running out of free space for the OS to store critical files.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>{HOST.NAME}: Free Disk {#FSNAME} Space {ITEM.LASTVALUE}</name>
                      <expression>{OS Windows Server Baseline:vfs.fs.size[{#FSNAME},pfree].last(0)}&lt;3</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{last(0)}&lt;10</expression>
                  <name>{HOST.NAME}: Free Disk {#FSNAME} Space {ITEM.LASTVALUE}</name>
                  <priority>INFO</priority>
                  <description>This measures the percentage of free space on the selected logical disk drive. Threshold: If this falls below 15 percent, you risk running out of free space for the OS to store critical files.</description>
                  <manual_close>YES</manual_close>
                  <dependencies>
                    <dependency>
                      <name>{HOST.NAME}: Free Disk {#FSNAME} Space {ITEM.LASTVALUE}</name>
                      <expression>{OS Windows Server Baseline:vfs.fs.size[{#FSNAME},pfree].last(0)}&lt;5</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>LogicalDisk Disk $1 Space Used %</name>
              <type>ZABBIX_ACTIVE</type>
              <key>vfs.fs.size[{#FSNAME},pused]</key>
              <delay>30s</delay>
              <value_type>FLOAT</value_type>
              <units>%</units>
              <description>LogicalDisk Space Used in percentes.</description>
              <applications>
                <application>
                  <name>Disk</name>
                </application>
              </applications>
            </item_prototype>
            <item_prototype>
              <name>LogicalDisk Disk $1 Space Total</name>
              <type>ZABBIX_ACTIVE</type>
              <key>vfs.fs.size[{#FSNAME},total]</key>
              <delay>1h</delay>
              <units>B</units>
              <description>LogicalDisk Space Total.</description>
              <applications>
                <application>
                  <name>Disk</name>
                </application>
              </applications>
            </item_prototype>
            <item_prototype>
              <name>LogicalDisk Disk $1 Space Used</name>
              <type>ZABBIX_ACTIVE</type>
              <key>vfs.fs.size[{#FSNAME},used]</key>
              <delay>30s</delay>
              <units>B</units>
              <description>LogicalDisk Space Used.</description>
              <applications>
                <application>
                  <name>Disk</name>
                </application>
              </applications>
            </item_prototype>
          </item_prototypes>
          <trigger_prototypes>
            <trigger_prototype>
              <expression>{OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Disk Transfers/sec",1].avg(300,0)}&lt;80 and {OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Read",1].avg(300,0)}>0.025</expression>
              <name>{HOST.NAME}: LogicalDisk Transfer(Read) Latency avg value &lt; 80 in the last 5 min</name>
              <priority>INFO</priority>
              <description>Indicates the number of read and writes completed per second, regardless of how much data they involve. Measures disk utilization. Threshold: Less than 80 I/O’s per second on average when disk latency is longer than 25 ms. This may indicate too many virtual LUNs using the same physical disks on a SAN.</description>
              <manual_close>YES</manual_close>
            </trigger_prototype>
            <trigger_prototype>
              <expression>{OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Disk Transfers/sec",1].avg(300,0)}&lt;80 and {OS Windows Server Baseline:perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Write",1].avg(300,0)}>0.025</expression>
              <name>{HOST.NAME}: LogicalDisk Transfer(Write) Latency avg value &lt; 80 in the last 5 min</name>
              <priority>INFO</priority>
              <description>Indicates the number of read and writes completed per second, regardless of how much data they involve. Measures disk utilization. Threshold: Less than 80 I/O’s per second on average when disk latency is longer than 25 ms. This may indicate too many virtual LUNs using the same physical disks on a SAN.</description>
              <manual_close>YES</manual_close>
            </trigger_prototype>
          </trigger_prototypes>
          <graph_prototypes>
            <graph_prototype>
              <name>LogicalDisk Disk {#FSNAME} Space</name>
              <graph_items>
                <graph_item>
                  <color>00C800</color>
                  <item>
                    <host>OS Windows Server Baseline</host>
                    <key>vfs.fs.size[{#FSNAME},free]</key>
                  </item>
                </graph_item>
                <graph_item>
                  <sortorder>1</sortorder>
                  <color>0000C8</color>
                  <item>
                    <host>OS Windows Server Baseline</host>
                    <key>vfs.fs.size[{#FSNAME},total]</key>
                  </item>
                </graph_item>
              </graph_items>
            </graph_prototype>
            <graph_prototype>
              <name>Logical Disk {#FSNAME} Read/Write Latency</name>
              <graph_items>
                <graph_item>
                  <color>00C800</color>
                  <item>
                    <host>OS Windows Server Baseline</host>
                    <key>perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Read",1]</key>
                  </item>
                </graph_item>
                <graph_item>
                  <sortorder>1</sortorder>
                  <color>C80000</color>
                  <item>
                    <host>OS Windows Server Baseline</host>
                    <key>perf_counter["\LogicalDisk({#FSNAME})\Avg. Disk sec/Write",1]</key>
                  </item>
                </graph_item>
              </graph_items>
            </graph_prototype>
          </graph_prototypes>
        </discovery_rule>
      </discovery_rules>
    </template>
  </templates>
  <triggers>
    <trigger>
      <expression>{OS Windows Server Baseline:perf_counter["\System\Context Switches/sec",1].avg(300,0)}/{OS Windows Server Baseline:system.cpu.num[online].last()}>5000</expression>
      <name>{HOST.NAME}: Context Switches/sec {ITEM.LASTVALUE}</name>
      <priority>WARNING</priority>
      <description>Indicates that the kernel has switched the thread it is running on a processor. A context switch occurs each time a new thread runs, and each time one thread takes over from another. A large number of threads is likely to increase the number of context switches. Context switches allow multiple threads to share time slices on the processors, but they also interrupt the processor and might reduce overall system performance, especially on multiprocessor computers. You should also observe the patterns of context switches over time. Threshold: High context switches/sec – more than 5000 context switches per second.</description>
      <manual_close>YES</manual_close>
    </trigger>
    <trigger>
      <expression>{OS Windows Server Baseline:perf_counter["\System\Context Switches/sec",1].avg(300,0)}/{OS Windows Server Baseline:system.cpu.num[online].last()}>10000</expression>
      <name>{HOST.NAME}: Context Switches/sec {ITEM.LASTVALUE}</name>
      <priority>AVERAGE</priority>
      <description>Indicates that the kernel has switched the thread it is running on a processor. A context switch occurs each time a new thread runs, and each time one thread takes over from another. A large number of threads is likely to increase the number of context switches. Context switches allow multiple threads to share time slices on the processors, but they also interrupt the processor and might reduce overall system performance, especially on multiprocessor computers. You should also observe the patterns of context switches over time. Threshold: Very high context switches/sec – more than 10,000 context switches per second.</description>
      <manual_close>YES</manual_close>
    </trigger>
  </triggers>
  <graphs>
    <graph>
      <name>Memory % Committed Bytes in Use</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Memory\% Committed Bytes in Use",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>Memory Free Page Table Entries</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Memory\Free System Page Table Entries",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>Memory Pages and Page Inputs</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Memory\Pages/sec",1]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>1</sortorder>
          <color>00C800</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Memory\Pages Input/sec",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>Memory Total, Cached, Available and Free</name>
      <graph_items>
        <graph_item>
          <color>0000C8</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>vm.memory.size[total]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>1</sortorder>
          <color>C80000</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>vm.memory.size[cached]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>2</sortorder>
          <color>00BB00</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>vm.memory.size[available]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>PhysicalDisk Avg. Disk Queue Length</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\PhysicalDisk(_Total)\Avg. Disk Queue Length",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>Processes IO Operations/sec</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Process(_Total)\IO Data Operations/sec",1]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>1</sortorder>
          <color>00C800</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Process(_Total)\IO Other Operations/sec",1]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>2</sortorder>
          <color>0000C8</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Process(_Total)\IO Read Operations/sec",1]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>3</sortorder>
          <color>C800C8</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Process(_Total)\IO Write Operations/sec",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>Processor and Server Queues</name>
      <graph_items>
        <graph_item>
          <color>C80000</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\System\Processor Queue Length",1]</key>
          </item>
        </graph_item>
        <graph_item>
          <sortorder>1</sortorder>
          <color>00C800</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\Server Work Queues(*)\Queue Length",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>System % Registry Quota In Use</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\System\% Registry Quota In Use",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
    <graph>
      <name>System Context Switches/sec</name>
      <graph_items>
        <graph_item>
          <color>FF3333</color>
          <item>
            <host>OS Windows Server Baseline</host>
            <key>perf_counter["\System\Context Switches/sec",1]</key>
          </item>
        </graph_item>
      </graph_items>
    </graph>
  </graphs>
  <value_maps>
    <value_map>
      <name>Windows service state</name>
      <mappings>
        <mapping>
          <value>0</value>
          <newvalue>Running</newvalue>
        </mapping>
        <mapping>
          <value>1</value>
          <newvalue>Paused</newvalue>
        </mapping>
        <mapping>
          <value>2</value>
          <newvalue>Start pending</newvalue>
        </mapping>
        <mapping>
          <value>3</value>
          <newvalue>Pause pending</newvalue>
        </mapping>
        <mapping>
          <value>4</value>
          <newvalue>Continue pending</newvalue>
        </mapping>
        <mapping>
          <value>5</value>
          <newvalue>Stop pending</newvalue>
        </mapping>
        <mapping>
          <value>6</value>
          <newvalue>Stopped</newvalue>
        </mapping>
        <mapping>
          <value>7</value>
          <newvalue>Unknown</newvalue>
        </mapping>
        <mapping>
          <value>255</value>
          <newvalue>No such service</newvalue>
        </mapping>
      </mappings>
    </value_map>
  </value_maps>
</zabbix_export>